import logging
import json
import re
from typing import Tuple, Dict
from backend.llm import GeminiLLM
import asyncio

# C·∫•u h√¨nh logging
logging.basicConfig(format="[QueryHandler] %(message)s", level=logging.INFO)
original_print = print

def print(*args, **kwargs):
    prefix = "[QueryHandler] "
    original_print(prefix + " ".join(map(str, args)), **kwargs)

logger = logging.getLogger(__name__)

class QueryHandler:
    """
    Module h·ª£p nh·∫•t x·ª≠ l√Ω v√† ph√¢n lo·∫°i c√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng trong m·ªôt b∆∞·ªõc duy nh·∫•t
    ƒë·ªÉ gi·∫£m s·ªë l·∫ßn g·ªçi LLM. Bao g·ªìm t√≠nh nƒÉng s·ª≠a l·ªói ch√≠nh t·∫£ v√† vi·∫øt t·∫Øt.
    H·ªó tr·ª£ async ƒë·∫ßy ƒë·ªß.
    """

    def __init__(self):
        """Kh·ªüi t·∫°o QueryHandler."""
        self.llm = GeminiLLM()

        # Dictionary c√°c t·ª´ vi·∫øt t·∫Øt v√† l·ªói ch√≠nh t·∫£ ph·ªï bi·∫øn trong lƒ©nh v·ª±c CSDL
        self.abbreviation_dict = {
            # Vi·∫øt t·∫Øt ti·∫øng Vi·ªát
            "cdld": "CSDL",
            "csdl": "CSDL", 
            "qtcsdl": "qu·∫£n tr·ªã c∆° s·ªü d·ªØ li·ªáu",
            "qtc∆°": "qu·∫£n tr·ªã c∆°",
            "hqtcsdl": "h·ªá qu·∫£n tr·ªã c∆° s·ªü d·ªØ li·ªáu",
            "h·ªá qtcsdl": "h·ªá qu·∫£n tr·ªã c∆° s·ªü d·ªØ li·ªáu",
            "h·ªá qt csdl": "h·ªá qu·∫£n tr·ªã c∆° s·ªü d·ªØ li·ªáu",
            "dbms": "DBMS",
            "rdbms": "RDBMS",
            "nosql": "NoSQL",
            "mongodb": "MongoDB",
            "mysql": "MySQL",
            "postgresql": "PostgreSQL",
            "sqlite": "SQLite",
            "oracle": "Oracle",
            "sqlserver": "SQL Server",
            "ms sql": "SQL Server",
            
            # L·ªói ch√≠nh t·∫£ ph·ªï bi·∫øn
            "co so du lieu": "c∆° s·ªü d·ªØ li·ªáu",
            "c∆° s·ªü d·ªØ li·ªáu": "c∆° s·ªü d·ªØ li·ªáu", # gi·ªØ nguy√™n n·∫øu ƒë√∫ng
            "quan tri": "qu·∫£n tr·ªã",
            "qu·∫£n tr·ªã": "qu·∫£n tr·ªã", # gi·ªØ nguy√™n n·∫øu ƒë√∫ng
            "du lieu": "d·ªØ li·ªáu",
            "d·ªØ li·ªáu": "d·ªØ li·ªáu", # gi·ªØ nguy√™n n·∫øu ƒë√∫ng
            "truy van": "truy v·∫•n",
            "truy v·∫•n": "truy v·∫•n", # gi·ªØ nguy√™n n·∫øu ƒë√∫ng
            "cau lenh": "c√¢u l·ªánh",
            "c√¢u l·ªánh": "c√¢u l·ªánh", # gi·ªØ nguy√™n n·∫øu ƒë√∫ng
            "bang": "b·∫£ng",
            "b·∫£ng": "b·∫£ng", # gi·ªØ nguy√™n n·∫øu ƒë√∫ng
            "truong": "tr∆∞·ªùng",
            "tr∆∞·ªùng": "tr∆∞·ªùng", # gi·ªØ nguy√™n n·∫øu ƒë√∫ng
            "khoa chinh": "kh√≥a ch√≠nh",
            "kh√≥a ch√≠nh": "kh√≥a ch√≠nh", # gi·ªØ nguy√™n n·∫øu ƒë√∫ng
            "khoa ngoai": "kh√≥a ngo·∫°i",
            "kh√≥a ngo·∫°i": "kh√≥a ngo·∫°i", # gi·ªØ nguy√™n n·∫øu ƒë√∫ng
            "chi muc": "ch·ªâ m·ª•c",
            "ch·ªâ m·ª•c": "ch·ªâ m·ª•c", # gi·ªØ nguy√™n n·∫øu ƒë√∫ng
            "backup": "sao l∆∞u",
            "restore": "kh√¥i ph·ª•c",
            
            # Vi·∫øt t·∫Øt SQL
            "select": "SELECT",
            "insert": "INSERT",
            "update": "UPDATE", 
            "delete": "DELETE",
            "create": "CREATE",
            "alter": "ALTER",
            "drop": "DROP",
            "join": "JOIN",
            "inner join": "INNER JOIN",
            "left join": "LEFT JOIN",
            "right join": "RIGHT JOIN",
            "full join": "FULL JOIN",
            "where": "WHERE",
            "group by": "GROUP BY",
            "order by": "ORDER BY",
            "having": "HAVING",
        }

    def _preprocess_query(self, query: str) -> str:
        """
        Ti·ªÅn x·ª≠ l√Ω c√¢u h·ªèi ƒë·ªÉ s·ª≠a l·ªói ch√≠nh t·∫£ v√† vi·∫øt t·∫Øt ph·ªï bi·∫øn.
        
        Args:
            query: C√¢u h·ªèi g·ªëc t·ª´ ng∆∞·ªùi d√πng
            
        Returns:
            C√¢u h·ªèi ƒë√£ ƒë∆∞·ª£c s·ª≠a l·ªói ch√≠nh t·∫£ v√† vi·∫øt t·∫Øt
        """
        processed_query = query.strip()
        
        # S·ª≠a c√°c t·ª´ vi·∫øt t·∫Øt v√† l·ªói ch√≠nh t·∫£
        for wrong_term, correct_term in self.abbreviation_dict.items():
            # S·ª≠ d·ª•ng regex ƒë·ªÉ thay th·∫ø t·ª´ c√≥ ranh gi·ªõi (word boundary)
            # ƒêi·ªÅu n√†y tr√°nh thay th·∫ø c√°c t·ª´ con
            pattern = r'\b' + re.escape(wrong_term) + r'\b'
            processed_query = re.sub(pattern, correct_term, processed_query, flags=re.IGNORECASE)
        
        # Log n·∫øu c√≥ thay ƒë·ªïi
        if processed_query != query:
            print(f"üîß ƒê√£ s·ª≠a query: '{query}' ‚Üí '{processed_query}'")
        
        return processed_query

    def _create_enhanced_prompt(self, query: str, conversation_history: str) -> str:
        """T·∫°o prompt ƒë∆∞·ª£c c·∫£i thi·ªán cho vi·ªác m·ªü r·ªông v√† ph√¢n lo·∫°i c√¢u h·ªèi."""
        # Cung c·∫•p l·ªãch s·ª≠ h·ªôi tho·∫°i, n·∫øu kh√¥ng c√≥ th√¨ th√¥ng b√°o
        history_context = conversation_history if conversation_history and conversation_history.strip() else "Kh√¥ng c√≥ l·ªãch s·ª≠ h·ªôi tho·∫°i."

        # X√¢y d·ª±ng prompt chi ti·∫øt v√† t·ªëi ∆∞u
        prompt = f"""
        B·∫°n l√† m·ªôt chuy√™n gia x·ª≠ l√Ω ng√¥n ng·ªØ t·ª± nhi√™n chuy√™n v·ªÅ c∆° s·ªü d·ªØ li·ªáu. Nhi·ªám v·ª• c·ªßa b·∫°n l√† ph√¢n t√≠ch "C√¢u h·ªèi hi·ªán t·∫°i" d·ª±a tr√™n "L·ªãch s·ª≠ h·ªôi tho·∫°i" v√† tr·∫£ v·ªÅ JSON v·ªõi ba tr∆∞·ªùng: "expanded_query", "query_type", v√† "corrections_made".

        **NHI·ªÜM V·ª§ CH√çNH:**

        1. **`expanded_query`** (M·ªü r·ªông v√† l√†m r√µ c√¢u h·ªèi):
           ‚Ä¢ Vi·∫øt l·∫°i c√¢u h·ªèi th√†nh d·∫°ng ho√†n ch·ªânh, ƒë·ªôc l·∫≠p, r√µ r√†ng
           ‚Ä¢ Gi·∫£i quy·∫øt t·∫•t c·∫£ tham chi·∫øu m∆° h·ªì ("n√≥", "c√°i ƒë√≥", "ch√∫ng", "nh∆∞ v·∫≠y")
           ‚Ä¢ X·ª≠ l√Ω c√°c ph·∫£n h·ªìi ng·∫Øn g·ªçn ("ok", "ƒë∆∞·ª£c", "ti·∫øp t·ª•c", "yes", "v√¢ng"):
             - N·∫øu AI v·ª´a ƒë·ªÅ xu·∫•t ch·ªß ƒë·ªÅ ‚Üí chuy·ªÉn th√†nh c√¢u h·ªèi c·ª• th·ªÉ v·ªÅ ch·ªß ƒë·ªÅ ƒë√≥
             - N·∫øu AI h·ªèi c√≥ mu·ªën ti·∫øp t·ª•c ‚Üí chuy·ªÉn th√†nh y√™u c·∫ßu ti·∫øp t·ª•c r√µ r√†ng
           ‚Ä¢ S·ª¨A L·ªñI CH√çNH T·∫¢ v√† CHU·∫®N H√ìA thu·∫≠t ng·ªØ:
             - "cdld" ‚Üí "CSDL"
             - "co so du lieu" ‚Üí "c∆° s·ªü d·ªØ li·ªáu" 
             - "quan tri" ‚Üí "qu·∫£n tr·ªã"
             - "du lieu" ‚Üí "d·ªØ li·ªáu"
             - C√°c l·ªánh SQL vi·∫øt th∆∞·ªùng ‚Üí VI·∫æT HOA (select ‚Üí SELECT)
           ‚Ä¢ B·∫£o to√†n v√† chu·∫©n h√≥a t·∫•t c·∫£ thu·∫≠t ng·ªØ k·ªπ thu·∫≠t

        2. **`query_type`** (Ph√¢n lo·∫°i ch√≠nh x√°c):
           
           ‚Ä¢ **`question_from_document`**: C√¢u h·ªèi v·ªÅ ki·∫øn th·ª©c CSDL c∆° b·∫£n/l√Ω thuy·∫øt
             - Kh√°i ni·ªám, ƒë·ªãnh nghƒ©a, nguy√™n l√Ω
             - So s√°nh c√¥ng ngh·ªá (SQL vs NoSQL) 
             - C√∫ ph√°p, c·∫•u tr√∫c l·ªánh SQL (√Ω nghƒ©a, m·ª•c ƒë√≠ch, quy t·∫Øc)
             - Thi·∫øt k·∫ø CSDL, m√¥ h√¨nh d·ªØ li·ªáu
             - Gi·∫£i th√≠ch l√Ω thuy·∫øt v·ªÅ l·ªánh SQL (kh√¥ng c√≥ code c·ª• th·ªÉ)
             - V√≠ d·ª•: "CSDL l√† g√¨?", "Kh√≥a ch√≠nh v√† kh√≥a ngo·∫°i kh√°c nhau nh∆∞ th·∫ø n√†o?", "C√∫ ph√°p l·ªánh SELECT l√† g√¨?"

           ‚Ä¢ **`realtime_question`**: C√¢u h·ªèi v·ªÅ xu h∆∞·ªõng/tin t·ª©c/th√¥ng tin c·∫≠p nh·∫≠t m·ªõi
             - C√≥ t·ª´ kh√≥a th·ªùi gian: "hi·ªán t·∫°i", "m·ªõi nh·∫•t", "2024", "g·∫ßn ƒë√¢y", "hi·ªán nay"
             - K·∫æT H·ª¢P v·ªõi √Ω ƒë·ªãnh t√¨m hi·ªÉu xu h∆∞·ªõng/tin t·ª©c/c·∫≠p nh·∫≠t m·ªõi
             - Xu h∆∞·ªõng c√¥ng ngh·ªá, phi√™n b·∫£n m·ªõi, th·ªëng k√™ th·ªã tr∆∞·ªùng
             - V√≠ d·ª•: "Xu h∆∞·ªõng CSDL hi·ªán t·∫°i", "PostgreSQL 16 c√≥ g√¨ m·ªõi?", "CSDL n√†o ph·ªï bi·∫øn nh·∫•t hi·ªán nay?"
             
             **CH√ö √ù**: Ph√¢n bi·ªát v·ªõi c√¢u h·ªèi c∆° b·∫£n:
             - "C√°c lo·∫°i CSDL" = question_from_document (h·ªèi ph√¢n lo·∫°i c∆° b·∫£n)
             - "CSDL n√†o ƒëang th·ªãnh h√†nh hi·ªán nay" = realtime_question (h·ªèi xu h∆∞·ªõng)

        **QUAN TR·ªåNG - PH√ÇN BI·ªÜT question_from_document vs sql_code_task:**
        - "C√∫ ph√°p l·ªánh SELECT l√† g√¨?" = question_from_document (h·ªèi l√Ω thuy·∫øt)
        - "Vi·∫øt l·ªánh SELECT l·∫•y d·ªØ li·ªáu" = sql_code_task (y√™u c·∫ßu code)
        - "C√°c m·ªánh ƒë·ªÅ c·ªßa SELECT" = question_from_document (h·ªèi ki·∫øn th·ª©c)  
        - "SELECT * FROM table WHERE..." = sql_code_task (c√≥ code c·ª• th·ªÉ)

           ‚Ä¢ **`sql_code_task`**: Y√™u c·∫ßu tr·ª±c ti·∫øp v·ªÅ code SQL C·ª§ TH·ªÇ
             - Vi·∫øt/t·∫°o c√¢u l·ªánh SQL ho√†n ch·ªânh
             - Gi·∫£i th√≠ch/ph√¢n t√≠ch code SQL C√ì S·∫¥N (c√≥ ƒëo·∫°n code c·ª• th·ªÉ)
             - Debug/t·ªëi ∆∞u h√≥a SQL v·ªõi code th·ª±c t·∫ø
             - T·∫°o v√≠ d·ª• code SQL minh h·ªça
             - **GI·∫¢I B√ÄI T·∫¨P CSDL** (d·∫°ng chu·∫©n, ph·ª• thu·ªôc h√†m, thi·∫øt k·∫ø ER...)
             - **PH√ÇN T√çCH T·ª™NG B∆Ø·ªöC** c√°c b√†i to√°n CSDL c·ª• th·ªÉ
             - V√≠ d·ª•: "Vi·∫øt SQL t·∫°o b·∫£ng User", "Gi·∫£i b√†i t·∫≠p x√°c ƒë·ªãnh d·∫°ng chu·∫©n", "T√¨m kh√≥a ch√≠nh cho l∆∞·ª£c ƒë·ªì n√†y"

           ‚Ä¢ **`other_question`**: Kh√¥ng li√™n quan ƒë·∫øn CSDL
             - CH·ªà d√πng khi ho√†n to√†n kh√¥ng li√™n quan sau khi m·ªü r·ªông
             - V√≠ d·ª•: "Th·ªùi ti·∫øt", "N·∫•u ƒÉn", "Th·ªÉ thao"

        3. **`corrections_made`** (Danh s√°ch s·ª≠a l·ªói):
           ‚Ä¢ M·∫£ng c√°c thay ƒë·ªïi ƒë√£ th·ª±c hi·ªán
           ‚Ä¢ Format: ["cdld ‚Üí CSDL", "co so ‚Üí c∆° s·ªü"]
           ‚Ä¢ ƒê·ªÉ m·∫£ng r·ªóng [] n·∫øu kh√¥ng c√≥ s·ª≠a ƒë·ªïi

        **V√ç D·ª§ TH·ª∞C T·∫æ:**

        Input: "Kh√°i ni·ªám h·ªá qu·∫£n tr·ªã cdld l√† g√¨?"
        ```json
        {{
          "expanded_query": "Kh√°i ni·ªám h·ªá qu·∫£n tr·ªã CSDL (C∆° s·ªü d·ªØ li·ªáu) l√† g√¨?",
          "query_type": "question_from_document",
          "corrections_made": ["cdld ‚Üí CSDL"]
        }}
        ```

        Input: "C√∫ ph√°p l·ªánh SELECT l√† g√¨?"
        ```json
        {{
          "expanded_query": "C√∫ ph√°p v√† ch·ª©c nƒÉng c·ªßa l·ªánh SELECT trong SQL l√† g√¨?",
          "query_type": "question_from_document",
          "corrections_made": []
        }}
        ```

        Input: "Vi·∫øt l·ªánh SELECT l·∫•y t·∫•t c·∫£ user"
        ```json
        {{
          "expanded_query": "Vi·∫øt c√¢u l·ªánh SQL SELECT ƒë·ªÉ l·∫•y t·∫•t c·∫£ th√¥ng tin ng∆∞·ªùi d√πng",
          "query_type": "sql_code_task",
          "corrections_made": []
        }}
        ```

        Input: "ok" (sau khi AI ƒë·ªÅ xu·∫•t t√¨m hi·ªÉu v·ªÅ Index)
        ```json
        {{
          "expanded_query": "T√¥i mu·ªën t√¨m hi·ªÉu v·ªÅ Index (ch·ªâ m·ª•c) trong c∆° s·ªü d·ªØ li·ªáu",
          "query_type": "question_from_document", 
          "corrections_made": []
        }}
        ```

        **NG·ªÆ C·∫¢NH:**
        L·ªãch s·ª≠ h·ªôi tho·∫°i:
        ---
        {history_context}
        ---

        **C√ÇU H·ªéI HI·ªÜN T·∫†I:** {query}

        H√£y tr·∫£ v·ªÅ JSON ch√≠nh x√°c v·ªõi 3 tr∆∞·ªùng nh∆∞ m√¥ t·∫£ tr√™n:
        """

        return prompt

    async def expand_and_classify_query(self, query: str, conversation_history: str) -> Tuple[str, str]:
        """
        M·ªü r·ªông v√† ph√¢n lo·∫°i c√¢u h·ªèi b·∫±ng LLM m·ªôt l·∫ßn duy nh·∫•t (b·∫•t ƒë·ªìng b·ªô)
        
        Args:
            query: C√¢u h·ªèi g·ªëc t·ª´ ng∆∞·ªùi d√πng
            conversation_history: L·ªãch s·ª≠ h·ªôi tho·∫°i ƒë·ªÉ cung c·∫•p ng·ªØ c·∫£nh
            
        Returns:
            Tuple c·ªßa (expanded_query, query_type)
        """
        print(f"üîÑ B·∫Øt ƒë·∫ßu x·ª≠ l√Ω v√† ph√¢n lo·∫°i query: '{query[:50]}...'")
        
        # B∆∞·ªõc 1: Ti·ªÅn x·ª≠ l√Ω c∆° b·∫£n
        preprocessed_query = self._preprocess_query(query)
        
        # B∆∞·ªõc 2: T·∫°o prompt v√† g·ªçi LLM
        enhanced_prompt = self._create_enhanced_prompt(preprocessed_query, conversation_history)
        
        try:
            # G·ªçi LLM b·∫•t ƒë·ªìng b·ªô
            response = await self.llm.invoke(enhanced_prompt)
            response_text = response.content.strip()
            print(f"üìù Raw LLM response: {response_text[:200]}...")
            
            # B∆∞·ªõc 3: Parse JSON response
            # T√¨m JSON trong response (c√≥ th·ªÉ c√≥ text ph·ª• xung quanh)
            json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
            if json_match:
                json_str = json_match.group()
                result = json.loads(json_str)
                
                expanded_query = result.get("expanded_query", preprocessed_query)
                query_type = result.get("query_type", "question_from_document")
                corrections_made = result.get("corrections_made", [])
                
                print(f"‚úÖ Expanded query: '{expanded_query}'")
                print(f"üè∑Ô∏è Query type: {query_type}")
                if corrections_made:
                    print(f"üîß Corrections made: {corrections_made}")
                
                return expanded_query, query_type
                
            else:
                print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y JSON trong response, s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh")
                return preprocessed_query, "question_from_document"
                
        except json.JSONDecodeError as e:
            print(f"‚ö†Ô∏è L·ªói parse JSON: {e}, s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh")
            return preprocessed_query, "question_from_document"
            
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói khi g·ªçi LLM: {e}, s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh")
            return preprocessed_query, "question_from_document"

    def expand_and_classify_query_sync(self, query: str, conversation_history: str) -> Tuple[str, str]:
        """
        M·ªü r·ªông v√† ph√¢n lo·∫°i c√¢u h·ªèi b·∫±ng LLM m·ªôt l·∫ßn duy nh·∫•t (ƒë·ªìng b·ªô - ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c)
        
        Args:
            query: C√¢u h·ªèi g·ªëc t·ª´ ng∆∞·ªùi d√πng
            conversation_history: L·ªãch s·ª≠ h·ªôi tho·∫°i ƒë·ªÉ cung c·∫•p ng·ªØ c·∫£nh
            
        Returns:
            Tuple c·ªßa (expanded_query, query_type)
        """
        print(f"üîÑ B·∫Øt ƒë·∫ßu x·ª≠ l√Ω v√† ph√¢n lo·∫°i query: '{query[:50]}...'")
        
        # B∆∞·ªõc 1: Ti·ªÅn x·ª≠ l√Ω c∆° b·∫£n
        preprocessed_query = self._preprocess_query(query)
        
        # B∆∞·ªõc 2: T·∫°o prompt v√† g·ªçi LLM
        enhanced_prompt = self._create_enhanced_prompt(preprocessed_query, conversation_history)
        
        try:
            # G·ªçi LLM ƒë·ªìng b·ªô
            response = self.llm.invoke_sync(enhanced_prompt)
            response_text = response.content.strip()
            print(f"üìù Raw LLM response: {response_text[:200]}...")
            
            # B∆∞·ªõc 3: Parse JSON response
            # T√¨m JSON trong response (c√≥ th·ªÉ c√≥ text ph·ª• xung quanh)
            json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
            if json_match:
                json_str = json_match.group()
                result = json.loads(json_str)
                
                expanded_query = result.get("expanded_query", preprocessed_query)
                query_type = result.get("query_type", "question_from_document")
                corrections_made = result.get("corrections_made", [])
                
                print(f"‚úÖ Expanded query: '{expanded_query}'")
                print(f"üè∑Ô∏è Query type: {query_type}")
                if corrections_made:
                    print(f"üîß Corrections made: {corrections_made}")
                
                return expanded_query, query_type
                
            else:
                print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y JSON trong response, s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh")
                return preprocessed_query, "question_from_document"
                
        except json.JSONDecodeError as e:
            print(f"‚ö†Ô∏è L·ªói parse JSON: {e}, s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh")
            return preprocessed_query, "question_from_document"
            
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói khi g·ªçi LLM: {e}, s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh")
            return preprocessed_query, "question_from_document"

    async def get_response_for_other_question(self, query: str) -> str:
        """
        T·∫°o ph·∫£n h·ªìi l·ªãch s·ª± cho nh·ªØng c√¢u h·ªèi kh√¥ng li√™n quan ƒë·∫øn lƒ©nh v·ª±c CSDL (b·∫•t ƒë·ªìng b·ªô)
        
        Args:
            query: C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng
            
        Returns:
            Ph·∫£n h·ªìi l·ªãch s·ª± h∆∞·ªõng d·∫´n ng∆∞·ªùi d√πng quay l·∫°i ch·ªß ƒë·ªÅ CSDL
        """
        default_response = f"""
        Xin ch√†o! T√¥i l√† DBR - chatbot chuy√™n v·ªÅ c∆° s·ªü d·ªØ li·ªáu. 

        C√¢u h·ªèi c·ªßa b·∫°n: "{query}" c√≥ v·∫ª kh√¥ng li√™n quan ƒë·∫øn lƒ©nh v·ª±c c∆° s·ªü d·ªØ li·ªáu m√† t√¥i ƒë∆∞·ª£c ƒë√†o t·∫°o ƒë·ªÉ h·ªó tr·ª£.

        T√¥i c√≥ th·ªÉ gi√∫p b·∫°n v·ªõi:
        ‚Ä¢ C√°c kh√°i ni·ªám v·ªÅ c∆° s·ªü d·ªØ li·ªáu
        ‚Ä¢ Thi·∫øt k·∫ø v√† chu·∫©n h√≥a CSDL  
        ‚Ä¢ Ng√¥n ng·ªØ SQL v√† c√°c truy v·∫•n
        ‚Ä¢ H·ªá qu·∫£n tr·ªã CSDL (MySQL, PostgreSQL, MongoDB...)
        ‚Ä¢ T·ªëi ∆∞u h√≥a hi·ªáu su·∫•t v√† b·∫£o m·∫≠t

        B·∫°n c√≥ mu·ªën h·ªèi g√¨ v·ªÅ c∆° s·ªü d·ªØ li·ªáu kh√¥ng? T√¥i s·∫Ω r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£! üòä
        """
        return default_response

    def get_response_for_other_question_sync(self, query: str) -> str:
        """
        T·∫°o ph·∫£n h·ªìi l·ªãch s·ª± cho nh·ªØng c√¢u h·ªèi kh√¥ng li√™n quan ƒë·∫øn lƒ©nh v·ª±c CSDL (ƒë·ªìng b·ªô)
        
        Args:
            query: C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng
            
        Returns:
            Ph·∫£n h·ªìi l·ªãch s·ª± h∆∞·ªõng d·∫´n ng∆∞·ªùi d√πng quay l·∫°i ch·ªß ƒë·ªÅ CSDL
        """
        default_response = f"""
        Xin ch√†o! T√¥i l√† DBR - chatbot chuy√™n v·ªÅ c∆° s·ªü d·ªØ li·ªáu. 

        C√¢u h·ªèi c·ªßa b·∫°n: "{query}" c√≥ v·∫ª kh√¥ng li√™n quan ƒë·∫øn lƒ©nh v·ª±c c∆° s·ªü d·ªØ li·ªáu m√† t√¥i ƒë∆∞·ª£c ƒë√†o t·∫°o ƒë·ªÉ h·ªó tr·ª£.

        T√¥i c√≥ th·ªÉ gi√∫p b·∫°n v·ªõi:
        ‚Ä¢ C√°c kh√°i ni·ªám v·ªÅ c∆° s·ªü d·ªØ li·ªáu
        ‚Ä¢ Thi·∫øt k·∫ø v√† chu·∫©n h√≥a CSDL  
        ‚Ä¢ Ng√¥n ng·ªØ SQL v√† c√°c truy v·∫•n
        ‚Ä¢ H·ªá qu·∫£n tr·ªã CSDL (MySQL, PostgreSQL, MongoDB...)
        ‚Ä¢ T·ªëi ∆∞u h√≥a hi·ªáu su·∫•t v√† b·∫£o m·∫≠t

        B·∫°n c√≥ mu·ªën h·ªèi g√¨ v·ªÅ c∆° s·ªü d·ªØ li·ªáu kh√¥ng? T√¥i s·∫Ω r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£! üòä
        """
        return default_response

    def test_preprocessing(self, test_queries=None) -> None:
        """
        Test ph∆∞∆°ng th·ª©c ti·ªÅn x·ª≠ l√Ω v·ªõi m·ªôt s·ªë c√¢u h·ªèi m·∫´u
        
        Args:
            test_queries: Danh s√°ch c√¢u h·ªèi ƒë·ªÉ test, n·∫øu None s·∫Ω d√πng m·∫´u c√≥ s·∫µn
        """
        if test_queries is None:
            test_queries = [
                "L√†m th·∫ø n√†o ƒë·ªÉ t·∫°o b·∫£ng trong mysql?",
                "C√°ch t·∫°o cdld m·ªõi",
                "co so du lieu la gi?",
                "quan tri csdl khac gi voi DBMS?",
                "select * from bang nao do",
                "inner join vs left join",
            ]
            
        print("üß™ Testing query preprocessing:")
        print("=" * 50)
        
        for query in test_queries:
            processed = self._preprocess_query(query)
            print(f"Original:  {query}")
            print(f"Processed: {processed}")
            print("-" * 30)

    def test_classification(self, test_queries=None) -> float:
        """
        Test ph∆∞∆°ng th·ª©c ph√¢n lo·∫°i v·ªõi c√°c c√¢u h·ªèi m·∫´u ƒë·ªÉ ki·ªÉm tra ƒë·ªô ch√≠nh x√°c
        
        Args:
            test_queries: Danh s√°ch tuple (query, expected_type), n·∫øu None s·∫Ω d√πng m·∫´u c√≥ s·∫µn
        """
        if test_queries is None:
            test_queries = [
                # question_from_document
                ("CSDL l√† g√¨?", "question_from_document"),
                ("C√∫ ph√°p l·ªánh SELECT l√† g√¨?", "question_from_document"),
                ("Kh√≥a ch√≠nh v√† kh√≥a ngo·∫°i kh√°c nhau nh∆∞ th·∫ø n√†o?", "question_from_document"),
                ("C√°c m·ªánh ƒë·ªÅ th∆∞·ªùng d√πng v·ªõi SELECT", "question_from_document"),
                ("M√¥ h√¨nh quan h·ªá c√≥ ∆∞u nh∆∞·ª£c ƒëi·ªÉm g√¨?", "question_from_document"),
                
                # sql_code_task
                ("Vi·∫øt l·ªánh SELECT l·∫•y t·∫•t c·∫£ user", "sql_code_task"),
                ("T·∫°o b·∫£ng sinh vi√™n v·ªõi SQL", "sql_code_task"),
                ("Gi·∫£i th√≠ch query n√†y: SELECT * FROM users WHERE age > 18", "sql_code_task"),
                ("T·ªëi ∆∞u h√≥a c√¢u l·ªánh SQL n√†y", "sql_code_task"),
                
                # realtime_question
                ("Xu h∆∞·ªõng CSDL hi·ªán t·∫°i l√† g√¨?", "realtime_question"),
                ("PostgreSQL 16 c√≥ g√¨ m·ªõi?", "realtime_question"),
                ("CSDL n√†o ph·ªï bi·∫øn nh·∫•t 2024?", "realtime_question"),
                ("C√¥ng ngh·ªá database n√†o ƒëang hot hi·ªán nay?", "realtime_question"),
                
                # other_question
                ("Th·ªùi ti·∫øt h√¥m nay th·∫ø n√†o?", "other_question"),
                ("C√°ch n·∫•u ph·ªü", "other_question"),
                ("K·∫øt qu·∫£ b√≥ng ƒë√°", "other_question"),
            ]
            
        print("üß™ Testing query classification:")
        print("=" * 80)
        
        correct_predictions = 0
        total_predictions = len(test_queries)
        
        for query, expected_type in test_queries:
            try:
                expanded_query, predicted_type = self.expand_and_classify_query_sync(query, "")
                
                is_correct = predicted_type == expected_type
                if is_correct:
                    correct_predictions += 1
                    status = "‚úÖ ƒê√öNG"
                else:
                    status = "‚ùå SAI"
                
                print(f"{status} | Query: {query}")
                print(f"      | Expected: {expected_type}")
                print(f"      | Predicted: {predicted_type}")
                print(f"      | Expanded: {expanded_query}")
                print("-" * 60)
                
            except Exception as e:
                print(f"‚ùå L·ªñI | Query: {query}")
                print(f"      | Error: {e}")
                print("-" * 60)
        
        accuracy = (correct_predictions / total_predictions) * 100
        print(f"\nüìä K·∫æT QU·∫¢ T·ªîNG K·∫æT:")
        print(f"   ƒê·ªô ch√≠nh x√°c: {correct_predictions}/{total_predictions} ({accuracy:.1f}%)")
        
        if accuracy >= 90:
            print("   üéâ Excellent! Classification working very well")
        elif accuracy >= 75:
            print("   üëç Good! Some edge cases need improvement")
        elif accuracy >= 60:
            print("   ‚ö†Ô∏è  Fair! Significant improvements needed")
        else:
            print("   üö® Poor! Major issues with classification")
        
        return accuracy